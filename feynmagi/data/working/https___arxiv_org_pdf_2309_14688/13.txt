ğ¿
(0.1) Discretize the service region Î© into a ğ‘šÃ—ğ‘› lattice of points, setting ğ‘¥ = (ğ‘–âˆ’0.5) , ğ‘– =
ğ‘–
ğ‘›
ğ‘Š
1,2,â€¦,ğ‘›, and ğ‘¦ = (ğ‘—âˆ’0.5) , ğ‘– = 1,2,â€¦,ğ‘š.
ğ‘—
ğ‘š
(0) (0) (0)
(0.2) Initialize ğ» (ğ‘¥ ) , ğ» (ğ‘¥ ) , and ğ‘† (ğ‘¥ ) to satisfy the boundary constraints for ğ‘– =
ğ¼ğ‘ ğ‘– ğ¼ğ‘‘ ğ‘– ğ¼ ğ‘–
1,2,â€¦,ğ‘›. Set the outer-loop iteration count ğ‘˜ = 1 and proceed to Stage 1.
Stage 1: Compute ğ‘©(ğ’™,ğ’š).
Calculate ğµ(ğ‘˜)(ğ‘¥ ,ğ‘¦ ) using Eq. (22d) for ğ‘– = 1,2,â€¦,ğ‘› , ğ‘— = 1,2,â€¦,ğ‘š , taking ğ»(ğ‘˜âˆ’1) (ğ‘¥ ) ,
ğ‘– ğ‘— ğ¼ğ‘ ğ‘–
(ğ‘˜âˆ’1) (ğ‘˜âˆ’1)
ğ» (ğ‘¥ ) , and ğ‘† (ğ‘¥ ) as inputs. Note that the integrals are approximated by summations.
ğ¼ğ‘‘ ğ‘– ğ¼ ğ‘–
Proceed to Stage 2.
Stage 2: Compute ğ‘¯ (ğ’™), ğ‘¯ (ğ’™) and ğ‘º (ğ’™).
ğ‘°ğ’‘ ğ‘°ğ’… ğ‘°
(2.1) Set ğ‘†Ìƒ(ğ‘˜,0) (ğ‘¥ )= ğ‘†(ğ‘˜âˆ’1) (ğ‘¥ ), ğ‘– = 1,2,â€¦,ğ‘›. Initialize the inner-loop iteration count ğ‘˜â€² = 1.
ğ¼ ğ‘– ğ¼ ğ‘–
(2.2) Taking ğµ(ğ‘˜)(ğ‘¥ ,ğ‘¦ ) and
ğ‘†Ìƒ(ğ‘˜,ğ‘˜â€²âˆ’1)
(ğ‘¥ ) (ğ‘– = 1,2,â€¦,ğ‘› , ğ‘— = 1,2,â€¦,ğ‘š ) as inputs, calculate
ğ‘– ğ‘— ğ¼ ğ‘–
ğ»Ìƒ
(ğ‘˜,ğ‘˜â€²)
(ğ‘¥ ) and ğ»Ìƒ
(ğ‘˜,ğ‘˜â€²)
(ğ‘¥ ) using Eqs. (22a)â€“(22b).
ğ¼ğ‘ ğ‘– ğ¼ğ‘‘ ğ‘–
(2.3) Taking ğµ(ğ‘˜)(ğ‘¥ ,ğ‘¦ ) , ğ»Ìƒ
(ğ‘˜,ğ‘˜â€²)
(ğ‘¥ ) , and ğ»Ìƒ
(ğ‘˜,ğ‘˜â€²)
(ğ‘¥ ) (ğ‘– = 1,2,â€¦,ğ‘› , ğ‘— = 1,2,â€¦,ğ‘š ) as
ğ‘– ğ‘— ğ¼ğ‘ ğ‘– ğ¼ğ‘‘ ğ‘–
inputs, calculate
ğ‘†Ìƒ(ğ‘˜,ğ‘˜â€²)
(ğ‘¥ ) by (22c).
ğ¼ ğ‘–
(2.4) Set ğ‘†(ğ‘˜) (ğ‘¥ )= ğ‘†Ìƒ(ğ‘˜,ğ‘˜â€²) (ğ‘¥ ) , ğ» (ğ‘˜)(ğ‘¥ ) = ğ»Ìƒ (ğ‘˜,ğ‘˜â€²) (ğ‘¥ ) , and ğ» (ğ‘˜)(ğ‘¥ )= ğ»Ìƒ (ğ‘˜,ğ‘˜â€²) (ğ‘¥ ) .
ğ¼ ğ‘– ğ¼ ğ‘– ğ¼ğ‘ ğ‘– ğ¼ğ‘ ğ‘– ğ¼ğ‘‘ ğ‘– ğ¼ğ‘‘ ğ‘–
Check for convergence using the predefined error tolerance ğœ€. If the following convergency
criteria are satisfied: âˆ‘ğ‘›
|ğ‘†Ìƒ(ğ‘˜,ğ‘˜â€²)
(ğ‘¥
)âˆ’ğ‘†Ìƒ(ğ‘˜,ğ‘˜â€²âˆ’1)
(ğ‘¥ )| â‰¤ ğ‘›ğœ€ and âˆ‘ğ‘› (|ğ»Ìƒ
(ğ‘˜,ğ‘˜â€²)
(ğ‘¥ )âˆ’
ğ‘–=1 ğ¼ ğ‘– ğ¼ ğ‘– ğ‘–=1 ğ¼ğ‘ ğ‘–
ğ»Ìƒ
(ğ‘˜,ğ‘˜â€²âˆ’1)
(ğ‘¥ )|+|ğ»Ìƒ
(ğ‘˜,ğ‘˜â€²)
(ğ‘¥ )âˆ’ğ»Ìƒ
(ğ‘˜,ğ‘˜â€²âˆ’1)
(ğ‘¥ )|)â‰¤ 2ğ‘›ğœ€ , then proceed to the next step.
ğ¼ğ‘ ğ‘– ğ¼ğ‘‘ ğ‘– ğ¼ğ‘‘ ğ‘–
Otherwise, update ğ‘˜â€² â†ğ‘˜â€²+1 and repeat steps (2.2) and (2.3).
(2.5) Check convergency. If âˆ‘ğ‘› |ğ‘†(ğ‘˜) (ğ‘¥ )âˆ’ğ‘†(ğ‘˜âˆ’1) (ğ‘¥ )|â‰¤ ğ‘›ğœ€ , âˆ‘ğ‘› (|ğ» (ğ‘˜)(ğ‘¥ )âˆ’
ğ‘–=1 ğ¼ ğ‘– ğ¼ ğ‘– ğ‘–=1 ğ¼ğ‘ ğ‘–
ğ» (ğ‘˜âˆ’1)(ğ‘¥ )|+|ğ» (ğ‘˜)(ğ‘¥ )âˆ’ğ» (ğ‘˜âˆ’1)(ğ‘¥ )|) â‰¤ 2ğ‘›ğœ€ , and âˆ‘ğ‘› âˆ‘ğ‘š |ğµ(ğ‘˜)(ğ‘¥ ,ğ‘¦ )âˆ’
ğ¼ğ‘ ğ‘– ğ¼ğ‘‘ ğ‘– ğ¼ğ‘‘ ğ‘– ğ‘–=1 ğ‘—=1 ğ‘– ğ‘—
ğµ(ğ‘˜âˆ’1)(ğ‘¥ ,ğ‘¦ )| â‰¤ ğ‘šğ‘›ğœ€ are all satisfied, set ğ‘†âˆ—(ğ‘¥ )= ğ‘†(ğ‘˜) (ğ‘¥ ) , ğ» âˆ—(ğ‘¥ )= ğ» (ğ‘˜)(ğ‘¥ ) ,
ğ‘– ğ‘— ğ¼ ğ‘– ğ¼ ğ‘– ğ¼ğ‘ ğ‘– ğ¼ğ‘ ğ‘–
ğ» âˆ—(ğ‘¥ )= ğ» (ğ‘˜)(ğ‘¥ ), and ğµâˆ—(ğ‘¥ ,ğ‘¦ ) = ğµ(ğ‘˜)(ğ‘¥ ,ğ‘¦ ) for ğ‘– = 1,2,â€¦,ğ‘›, ğ‘— = 1,2,â€¦,ğ‘š, and
ğ¼ğ‘‘ ğ‘– ğ¼ğ‘‘ ğ‘– ğ‘– ğ‘— ğ‘– ğ‘—
end the search. Otherwise, update ğ‘˜ â† ğ‘˜+1 and return to Stage 1.
The optimal CA solution, obtained on the point lattice, can be transformed into a specific layout of
feeder lines. The methodology for this conversion is detailed in Appendix C.
4. Numerical case studies
Section 4.1 outlines the setup of numerical case studies. The accuracy of our CA models is examined
in Section 4.2. Optimal feeder system designs for a typical case in both high- and low-wage cities are
presented and discussed in Section 4.3. In Section 4.4, the sensitivity of the optimal feeder design to
various key operating factors, such as demand pattern, demand rate, size of the service region, and
14